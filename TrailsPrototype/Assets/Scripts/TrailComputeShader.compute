// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Update

struct Flyer {
    float2 pos;
    float angle;
};


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Texture;
RWStructuredBuffer<Flyer> flyers;

uint width;
uint height;
uint numFlyers;
float flySpeed;
float deltaTime;
float reduceSpeed;

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}





[numthreads(16,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if(id.x >= numFlyers) { return; }


    Flyer temp = flyers[id.x];
    uint random = hash(temp.pos.x * width + temp.pos.y + hash(id.x));

    //Move flyer based on direction and speed given
    float2 dir = float2(cos(temp.angle), sin(temp.angle));
    float2 newPos = temp.pos + dir * flySpeed * deltaTime;

    //Clamp flyer pos to inside the screen and bounce off wall
    if (newPos.x < 0 || newPos.y < 0 || newPos.x >= width || newPos.y >= height) {
        newPos.x = min(width - 0.01, max(0, newPos.x));
        newPos.y = min(height - 0.01, max(0, newPos.y));
        flyers[id.x].angle *= -1;
    }


    flyers[id.x].pos = newPos;
    Texture[int2(newPos.x, newPos.y)] = 1;
    
    if (id.x < 0 || id.y < 0 || id.x >= width || id.y >= height) { return; }

    float4 originalValue = Texture[id.xy];
    float4 newValue = max(0, originalValue - reduceSpeed * deltaTime);
    Texture[id.xy] = newValue;
}



